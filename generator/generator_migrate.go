// generator_migrate.go
package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"
)

const migrateTemplate = `// Code generated by go generate; DO NOT EDIT.
package models

import (
    "fmt"
    "github.com/Alexandr-Fox/fox-core/internal/database"
)

// Migrate запускает AutoMigrate для всех моделей
func Migrate() {
    cfg := database.ReadDatabaseConfig()

    database.GetCoreDB().Exec(fmt.Sprintf("CREATE SCHEMA IF NOT EXISTS %s", cfg.Schema))

    err := database.GetCoreDB().AutoMigrate({{range $i, $model := .Models}}{{if $i}}, {{end}}&{{$model}}{}{{end}})
    if err != nil {
        panic(err)
    }
}
`

type MigrateData struct {
	Models []string
}

func main() {
	modelsDir := "internal/models"
	outputFile := filepath.Join(modelsDir, "migrate.go")

	fset := token.NewFileSet()
	var models []string

	// Чтение всех .go файлов в папке models
	files, err := ioutil.ReadDir(modelsDir)
	if err != nil {
		log.Fatalf("Не удалось прочитать папку %s: %v", modelsDir, err)
	}

	for _, file := range files {
		if !strings.HasSuffix(file.Name(), ".go") || strings.HasSuffix(file.Name(), "_test.go") || file.Name() == "migrate.go" || strings.HasSuffix(file.Name(), ".generated.go") {
			continue // пропускаем тесты и сам файл миграций
		}

		filePath := filepath.Join(modelsDir, file.Name())
		f, err := parser.ParseFile(fset, filePath, nil, parser.ParseComments)
		if err != nil {
			log.Printf("Ошибка парсинга файла %s: %v", filePath, err)
			continue
		}

		// Ищем определения типов-структур
		ast.Inspect(f, func(n ast.Node) bool {
			if spec, ok := n.(*ast.TypeSpec); ok {
				if _, ok := spec.Type.(*ast.StructType); ok {
					if strings.HasPrefix(spec.Name.Name, "_") {
						fmt.Printf("⚠️ Пропускаем генерацию для структуры %s из-за префикса\n", spec.Name.Name)
						return true
					}

					models = append(models, spec.Name.Name)
				}
			}
			return true
		})
	}

	if len(models) == 0 {
		log.Println("Модели не найдены.")
		return
	}

	// Убираем дубликаты (на всякий случай)
	seen := make(map[string]bool)
	var uniqueModels []string
	for _, m := range models {
		if !seen[m] {
			seen[m] = true
			uniqueModels = append(uniqueModels, m)
		}
	}

	// Сортируем для предсказуемого порядка
	sort.Strings(uniqueModels)

	// Генерируем файл
	data := MigrateData{Models: uniqueModels}

	tmpl, err := template.New("migrate").Parse(migrateTemplate)
	if err != nil {
		log.Fatalf("Ошибка парсинга шаблона: %v", err)
	}

	out, err := os.Create(outputFile)
	if err != nil {
		log.Fatalf("Не удалось создать файл %s: %v", outputFile, err)
	}
	defer out.Close()

	err = tmpl.Execute(out, data)
	if err != nil {
		log.Fatalf("Ошибка генерации кода: %v", err)
	}

	fmt.Printf("✅ Сгенерирован файл %s с %d моделями.\n", outputFile, len(uniqueModels))
}
