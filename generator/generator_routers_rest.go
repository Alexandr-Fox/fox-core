// generator/generator_routers_rest.go
package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"strings"
	"text/template"
	"unicode"
)

const outputControllers = "router/rest.generated.go"

type Controller struct {
	Route    string
	Model    string
	Func     string
	Auth     bool
	OnlyPost bool
}

func toLowerCamel(s string) string {
	if s == "" {
		return ""
	}
	runes := []rune(s)
	runes[0] = unicode.ToLower(runes[0])
	return string(runes)
}

func main() {
	fset := token.NewFileSet()
	controllersPath := "controllers"

	pkgs, err := parser.ParseDir(fset, controllersPath, nil, parser.ParseComments)
	if err != nil {
		log.Fatal("Ошибка парсинга пакета controllers: ", err)
	}

	var controllers []Controller

	for _, pkg := range pkgs {
		for fileName, file := range pkg.Files {
			if !strings.HasSuffix(fileName, ".go") || strings.HasSuffix(fileName, "_test.go") {
				continue
			}

			ast.Inspect(file, func(n ast.Node) bool {
				typeSpec, ok := n.(*ast.TypeSpec)
				if !ok || typeSpec.Type == nil {
					return true
				}

				_, ok = typeSpec.Type.(*ast.StructType)
				if !ok {
					return true
				}

				modelName := typeSpec.Name.Name

				if strings.HasPrefix(modelName, "_") {
					fmt.Printf("⚠️ Пропускаем генерацию для структуры %s из-за префикса\n", modelName)
					return true
				}
				commentMap := ast.NewCommentMap(fset, file, file.Comments)

				// Проверим методы
				for _, method := range pkg.Files[fileName].Decls {
					fn, ok := method.(*ast.FuncDecl)
					if !ok || fn.Recv == nil || fn.Recv.List == nil {
						continue
					}

					// Проверим, что метод принадлежит этой структуре
					recv := fn.Recv.List[0].Type
					var recvName string
					switch t := recv.(type) {
					case *ast.Ident:
						recvName = t.Name
					case *ast.StarExpr:
						if ident, ok := t.X.(*ast.Ident); ok {
							recvName = ident.Name
						}
					}

					if recvName != modelName {
						continue
					}

					authRequire := false
					onlyPost := false
					if comments := commentMap[method]; len(comments) > 0 {
						for _, group := range comments {
							for _, comment := range group.List {
								text := comment.Text
								// Убираем префиксы // или /* */
								if strings.HasPrefix(text, "//") {
									tagLine := strings.TrimSpace(strings.TrimPrefix(text, "//"))
									if strings.HasPrefix(tagLine, "@rpc") || strings.HasPrefix(tagLine, "+") || strings.HasPrefix(tagLine, "-") {
										if strings.HasSuffix(tagLine, "+requireAuth") || strings.HasSuffix(tagLine, ":requireAuth") {
											authRequire = true
										} else if strings.HasSuffix(tagLine, "-requireAuth") {
											authRequire = false
										} else if strings.HasSuffix(tagLine, "+onlyPost") || strings.HasSuffix(tagLine, ":onlyPost") {
											onlyPost = true
										} else if strings.HasSuffix(tagLine, "-onlyPost") {
											onlyPost = false
										}
									}
								}
							}
						}
					}

					controllers = append(controllers, Controller{
						Route:    fmt.Sprintf("%s.%s", toLowerCamel(modelName), toLowerCamel(fn.Name.Name)),
						Model:    modelName,
						Func:     fn.Name.Name,
						Auth:     authRequire,
						OnlyPost: onlyPost,
					})
				}

				return true
			})
		}
	}

	if len(controllers) == 0 {
		log.Println("Не найдено контроллеров. Генерация пустого файла.")
	}

	// Генерация кода
	err = generateControllersRoutes(controllers)
	if err != nil {
		log.Fatal("Ошибка генерации файла: ", err)
	}

	fmt.Println("✅ Сгенерирован:", outputControllers)
}

func generateControllersRoutes(controllers []Controller) error {
	requireAuth := false

	for _, controller := range controllers {
		requireAuth = requireAuth || controller.Auth
	}

	type controllersStruct struct {
		Auth        bool
		Controllers []Controller
	}

	controllerImport := controllersStruct{
		Controllers: controllers,
		Auth:        requireAuth,
	}

	tmpl := `// Code generated by go generate; DO NOT EDIT.
package router

import (
    "github.com/gofiber/fiber/v2"
	{{if gt (len .Controllers) 0}}"github.com/Alexandr-Fox/fox-core/controllers"{{end}}
	{{if .Auth}}"github.com/Alexandr-Fox/fox-core/middleware"{{end}}
)

// RegisterRESTRoutes регистрирует REST-роуты для всех моделей
func RegisterRESTRoutes(app *fiber.App) {
	{{if gt (len .Controllers) 0}}api := app.Group("/api"){{end}}
    {{range $r := .Controllers}}
	{{$r.Model}}{{$r.Func}} := func(c *fiber.Ctx) error {
		model := controllers.New{{$r.Model}}()
		if err := model.{{$r.Func}}(c); err != nil {return err.(error)}
		return c.SendStatus(fiber.StatusOK)
	}{{if not $r.OnlyPost}}
    api.Get("/{{$r.Route}}"{{if $r.Auth}}, middleware.Auth{{end}}, {{$r.Model}}{{$r.Func}}){{end}}
    api.Post("/{{$r.Route}}"{{if $r.Auth}}, middleware.Auth{{end}}, {{$r.Model}}{{$r.Func}})
    {{end}}
}
`

	t, err := template.New("controllers").Parse(tmpl)
	if err != nil {
		return err
	}

	file, err := os.Create(outputControllers)
	if err != nil {
		return err
	}
	defer file.Close()

	return t.Execute(file, controllerImport)
}
