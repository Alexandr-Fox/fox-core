// generator_methods.go
package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"
	"unicode"
)

// Шаблон для генерации метода Delete
const header = `// Code generated by go generate; DO NOT EDIT.
package models

import ({{range $i, $import := .Imports}}
    "{{$import}}"{{end}}
)

func New{{.ModelName}}() *{{.ModelName}} {
	return &{{.ModelName}}{}
}
`

// Шаблон для генерации метода Delete
const deleteMethodTemplate = `
func ({{.ModelVar}} *{{.ModelName}}) Delete() error {
	return database.GetCoreDB().Delete(&{{.ModelVar}}, fmt.Sprintf(consts.QueryEqOne, consts.FieldID), {{.ModelVar}}.ID).Error
}
`

// Шаблон для генерации метода Load
const loadMethodTemplate = `
func ({{.ModelVar}} *{{.ModelName}}) Load(query ...database.LoadQuery) ({{.ModelVar}}s []{{.ModelName}}, err error) {
	if len(query) > 1 {
		return []{{.ModelName}}{}, errors.New(consts.ErrorArgumentsCount)
	}

	qb := database.GetCoreDB().Model(&{{.ModelVar}})

	if len(query) > 0 {
		for _, v := range query[0].Preload {
			qb = qb.Preload(v)
		}

		query, values := database.ParseQuery(query[0].Filter)
		qb = qb.Where(query, values...)
	}

	err = qb.Find(&{{.ModelVar}}s).Error

	return {{.ModelVar}}s, err
}
`

// Шаблон для генерации метода Load
const findMethodTemplate = `
func ({{.ModelVar}} *{{.ModelName}}) Find(name string, value interface{}) ({{.ModelVar}}s []{{.ModelName}}, err error) {
	if err = database.GetCoreDB().Where(fmt.Sprintf(consts.QueryEqOne, name), value).Find(&{{.ModelVar}}s).Error; err != nil {
		return nil, err
	}

	return {{.ModelVar}}s, nil
}
`

// Шаблон для генерации метода Find
const firstMethodTemplate = `
func ({{.ModelVar}} *{{.ModelName}}) First(name string, value interface{}) error {
	if err := database.GetCoreDB().Where(fmt.Sprintf(consts.QueryEqOne, name), value).First(&{{.ModelVar}}).Error; err != nil {
		return err
	}

	return nil
}
`

// Шаблон для генерации метода Create
const createMethodTemplate = `
func ({{.ModelVar}} *{{.ModelName}}) Create() error {
    return database.GetCoreDB().Create({{.ModelVar}}).Error
}
`

// Шаблон для генерации метода Save
const saveMethodTemplate = `
func ({{.ModelVar}} *{{.ModelName}}) Save() error {
    return database.GetCoreDB().Save({{.ModelVar}}).Error
}
`

// Структура для шаблона
type MethodInfo struct {
	ModelName string
	ModelVar  string
	Imports   []string
}

func toInitials(s string) string {
	var initials []rune

	for i, r := range s {
		// Если это первая буква строки, добавляем её
		if i == 0 {
			initials = append(initials, unicode.ToLower(r))
		} else {
			// Если текущая буква — заглавная, значит, это начало нового слова
			if unicode.IsUpper(r) {
				initials = append(initials, unicode.ToLower(r))
			}
		}
	}

	return string(initials)
}

func main() {
	modelsDir := "internal/models"

	// Получаем список файлов .go в папке models
	files, err := os.ReadDir(modelsDir)
	if err != nil {
		log.Fatalf("Не удалось прочитать папку models: %v", err)
	}

	fset := token.NewFileSet()

	// Собираем все структуры из пакета
	structs := make(map[string]map[string]bool) // имя структуры -> есть ли метод Create

	for _, file := range files {
		if !strings.HasSuffix(file.Name(), ".go") || strings.HasSuffix(file.Name(), "_test.go") || strings.HasSuffix(file.Name(), ".generated.go") {
			continue
		}

		filePath := filepath.Join(modelsDir, file.Name())
		f, err := parser.ParseFile(fset, filePath, nil, parser.ParseComments)
		if err != nil {
			log.Printf("Ошибка парсинга файла %s: %v", filePath, err)
			continue
		}

		// Ищем определения структур
		for _, decl := range f.Decls {
			if genDecl, ok := decl.(*ast.GenDecl); ok && genDecl.Tok == token.TYPE {
				for _, spec := range genDecl.Specs {
					if typeSpec, ok := spec.(*ast.TypeSpec); ok {
						if _, ok := typeSpec.Type.(*ast.StructType); ok {
							if strings.HasPrefix(typeSpec.Name.Name, "_") {
								fmt.Printf("⚠️ Пропускаем генерацию для структуры %s из-за префикса\n", typeSpec.Name.Name)
								continue
							}

							structs[typeSpec.Name.Name] = map[string]bool{
								"Create": false,
								"Delete": false,
								"Find":   false,
								"First":  false,
								"Load":   false,
							} // пока считаем, что метода нет
						}
					}
				}
			}
		}

		// Ищем методы
		for _, decl := range f.Decls {
			if funcDecl, ok := decl.(*ast.FuncDecl); ok {
				if funcDecl.Recv != nil && len(funcDecl.Recv.List) > 0 {
					recv := funcDecl.Recv.List[0]
					// Получаем имя типа получателя
					var recvTypeName string
					switch t := recv.Type.(type) {
					case *ast.StarExpr:
						if ident, ok := t.X.(*ast.Ident); ok {
							recvTypeName = ident.Name
						}
					case *ast.Ident:
						recvTypeName = t.Name
					}
					if recvTypeName != "" {
						if _, exists := structs[recvTypeName]; exists {
							structs[recvTypeName][funcDecl.Name.Name] = true
						}
					}
				}
			}
		}
	}

	// Генерируем метод Create для структур, у которых его нет
	for modelName, methods := range structs {
		if len(getTrueKeysSorted(methods)) > 0 {
			generateMethods(modelName, getTrueKeysSorted(methods), modelsDir)
		}
	}
}
func getTrueKeysSorted(m map[string]bool) []string {
	var keys []string
	for k, v := range m {
		if !v {
			keys = append(keys, k)
		}
	}
	sort.Strings(keys)
	return keys
}

func getMapKeys[K comparable, V any](m map[K]V) []K {
	keys := make([]K, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	return keys
}

func generateMethods(modelName string, methods []string, outputDir string) {
	fileName := filepath.Join(outputDir, fmt.Sprintf("%s.generated.go", strings.ToLower(modelName)))

	file, err := os.Create(fileName)
	if err != nil {
		log.Printf("Не удалось создать файл %s: %v", fileName, err)
		return
	}
	defer file.Close()

	fullTmpl := header
	imports := map[string]bool{"github.com/Alexandr-Fox/fox-core/internal/database": true, "github.com/Alexandr-Fox/fox-core/internal/consts": true}

	for _, method := range methods {
		switch method {
		case "Create":
			{
				fullTmpl += createMethodTemplate
				break
			}
		case "Save":
			{
				fullTmpl += saveMethodTemplate
				break
			}
		case "Delete":
			{
				imports["fmt"] = true

				fullTmpl += deleteMethodTemplate
				break
			}
		case "Load":
			{
				imports["errors"] = true

				fullTmpl += loadMethodTemplate
				break
			}
		case "Find":
			{
				imports["fmt"] = true

				fullTmpl += findMethodTemplate
				break
			}
		case "First":
			{
				imports["fmt"] = true

				fullTmpl += firstMethodTemplate
				break
			}
		}
	}

	tmpl, err := template.New("methods").Parse(fullTmpl)
	if err != nil {
		log.Printf("Ошибка парсинга шаблона: %v", err)
		return
	}

	err = tmpl.Execute(file, MethodInfo{ModelName: modelName, ModelVar: toInitials(modelName), Imports: getMapKeys(imports)})
	if err != nil {
		log.Printf("Ошибка генерации кода для %s: %v", modelName, err)
		return
	}

	fmt.Printf("✅ Сгенерировано %d методов для модели %s в файле %s\n", len(methods), modelName, fileName)
}
